# 아기 상어

### 조건

---

- 아기 상어의 초기 크기는 2
- 1초에 상하좌우로 한 칸씩 이동
- 아기 상어는 자기보다 큰 물고기가 있는 칸을 지나갈 수 없다.
- 아기 상어는 자기보다 작은 물고기만 먹을 수 있다.
- 크기가 같은 물고기는 먹을 수 없지만, 그 물고기가 있는 칸은 지나갈 수 있다.
- 거리가 가장 가까운 물고기
    - 거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기
- 이동과 동시에 물고기를 먹을 수 있다.
- 아기 상어는 자신의 크기와 같은 수의 물고기를 먹을 때 마다 크기가 1 증가한다. 예를 들어, 크기가 2인 아기 상어는 물고기를 2마리 먹으면 크기가 3이 된다.
- 공간의 상태가 주어졌을 때, 아기 상어가 몇 초 동안 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는지 구하는 프로그램을 작성

### 해결 과정

---

1. 어떤 상황이든 BFS를 진행함
    1. ‘상하좌우’ 순서로 사방 탐색을 진행
    2. 결과는 당연히 **시간 초과**

BFS는 **가중치가 없는** 간선에서는 **항상 최소 거리를 보장**하니, 현재 먹을 수 있는 물고기를 발견했을 때, **이전의** 찾은 **물고기의 거리보다 길다면**, BFS 종료

1. 위 내용에 더하여, **거리가 같고** 먹을 수 있는 물고기가 여러 개라면, **가장 위**에 있고, **가장 왼쪽**에 있는 물고기를 선택해야 하기에,  사방탐색의 순서를 ‘**상좌**우하’로 변경
    1. 결과는 **2%**에서 **시간 초과** 
2. 우선순위 큐의 문제인가?
    1. 우선순위 큐를 사용하지 않고, ‘상좌우하’로 탐색하면서 먹을 수 있는 물고기를 하나 발견하면, 무조건 종료되도록 설계
        
        ```
        [5, 4, **9**, 0, **3**, 4]
        [4, **3**, 0, **3**, 4, 5]
        [3, 2, 0, 5, 6, 6]
        [2, 0, 0, 3, 4, 5]
        [3, 2, 0, 6, 5, 4]
        [6, 6, 6, 6, 6, 6]
        -> 위의 경우 보라색 물고기를 먼저 먹어야한다.
        
        [5, 4, 0, 0, **3**, 4]
        [4, **9**, 0, 3, 4, 5]
        [3, 2, 0, 5, 6, 6]
        [2, 0, 0, 3, 4, 5]
        [3, 2, 0, 6, 5, 4]
        [6, 6, 6, 6, 6, 6]
        -> 하지만 왼쪽 아래의 물고기를 먹게된다.
        ```
        
    2. 위 방법은 틀림
3. 결국 스스로 해결하지 못 하고, *질문 게시판*으로
    
    [글 읽기 - 시간초과 해결안되시는분들 정보공유합니다](https://www.acmicpc.net/board/view/61245)
    
    - BFS가 시간초과나는 경우
        1. BFS를 잘못 설계하여, 무한 루프에 빠지는 경우
        2. 시작 지점을 방문처리하지 않은 경우
        3. 큐에 넣기 전에 방문처리를 하지 않고, 큐에서 꺼낼 때 하는 경우
        4. 아기 상어가 큰 물고기에 둘러쌓여 움직이지 못 하는 경우
        5. 도착지를 찾지 못 하는 경우
            1. 처음 시작 시, 먹을 수 있는 물고기가 없는 경우
            2. 이 조건을 추가하니 **해결 완료**

### BFS 가지치기

---

```java
/* 
 * **첫 번째 시간 단축 방법**
 * - 현재 공간에 더 이상 먹을 수 있는 물고기가 없는지 판단하기 
 */
numOfFish = 0;	// 현재 아기 상어가 먹을 수 있는 먹이 개수
int size = Math.min(sharkSize, 7);	// 아기 상어의 크기가 7보다 커질 수 있다.
for (int i = 1; i < size; i++) {
	numOfFish += numOfEachFish[i];
}

/* 
 * **두 번째 시간 단축 방법**
 * - 아기 상어가 먹을 수 있는 가장 가까운 물고기를 찾은 경우
 */
if (!canEat.isEmpty() && canEat.peek()[2] < cDist + 1) {
	flag = true;
	break;
}

/* 
 * **세 번째 시간 단축 방법**
 * - 아기 상어가 사방으로 아기 상어 크기보다 큰 물고기로 둘러싸인 경우
 */
if (canEat.isEmpty())
	return true;
```
